/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.alibaba.polardbx.proxy.protocol.connection;

import com.alibaba.polardbx.proxy.protocol.common.MysqlPacket;
import com.alibaba.polardbx.proxy.protocol.decoder.Decoder;
import com.alibaba.polardbx.proxy.protocol.encoder.Encoder;
import com.alibaba.polardbx.proxy.utils.BytesTools;
import lombok.Getter;
import lombok.Setter;
import org.jetbrains.annotations.NotNull;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

@Getter
@Setter
public class HandshakeResponse41 implements MysqlPacket {
    /**
     * https://dev.mysql.com/doc/dev/mysql-server/latest/page_protocol_connection_phase_packets_protocol_handshake_response.html
     * <p>
     * Type	Name	Description
     * int<4>	client_flag	Capabilities Flags, CLIENT_PROTOCOL_41 always set.
     * int<4>	max_packet_size	maximum packet size
     * int<1>	character_set	client charset a_protocol_character_set, only the lower 8-bits
     * string[23]	filler	filler to the size of the handhshake response packet. All 0s.
     * string<NUL>	username	login user name
     * if capabilities & CLIENT_PLUGIN_AUTH_LENENC_CLIENT_DATA {
     * string<length>	auth_response	opaque authentication response data generated by Authentication Method indicated by the plugin name field.
     * } else {
     * int<1>	auth_response_length	length of auth_response
     * string<length>	auth_response	opaque authentication response data generated by Authentication Method indicated by the plugin name field.
     * }
     * if capabilities & CLIENT_CONNECT_WITH_DB {
     * string<NUL>	database	initial database for the connection. This string should be interpreted using the character set indicated by character set field.
     * }
     * if capabilities & CLIENT_PLUGIN_AUTH {
     * string<NUL>	client_plugin_name	the Authentication Method used by the client to generate auth-response value in this packet. This is an UTF-8 string.
     * }
     * if capabilities & CLIENT_CONNECT_ATTRS {
     * int<lenenc>	length of all key-values	affected rows
     * string<lenenc>	key1	Name of the 1st client attribute
     * string<lenenc>	value1	Value of the 1st client attribute
     * .. (if more data in length of all key-values, more keys and values parts)
     * }
     * if capabilities & CLIENT_ZSTD_COMPRESSION_ALGORITHM {
     * int<1>	zstd_compression_level	compression level for zstd compression algorithm
     * }
     */
    private int clientFlag;
    private int maxPacketSize;
    private byte characterSet;
    private byte[] username;
    private byte[] authResponse;
    private byte[] database;
    private byte[] authPluginName;

    @Getter
    public static class Attribute {
        private final byte[] key;
        private final byte[] value;

        public Attribute(byte @NotNull [] key, byte @NotNull [] value) {
            this.key = key;
            this.value = value;
        }

        @Override
        public String toString() {
            return new String(key) + '=' + new String(value);
        }
    }

    private List<Attribute> attributes;
    private byte zstdCompressionLevel;

    public HandshakeResponse41() {
    }

    @Override
    public void decode(Decoder decoder, int ignored) {
        if (decoder.remaining() < 34) {
            throw new IllegalArgumentException("invalid handshake response");
        }
        this.clientFlag = (int) decoder.u32();
        if (0 == (this.clientFlag & Capabilities.CLIENT_PROTOCOL_41)) {
            throw new IllegalArgumentException("not MySQL 41 protocol");
        }
        this.maxPacketSize = (int) decoder.u32();
        this.characterSet = (byte) decoder.u8();
        decoder.skip(23);
        this.username = decoder.str();
        final int authResponseLength;
        if ((this.clientFlag & Capabilities.CLIENT_PLUGIN_AUTH_LENENC_CLIENT_DATA) != 0) {
            authResponseLength = (int) decoder.lei_s();
        } else {
            authResponseLength = decoder.u8_s();
        }
        this.authResponse = decoder.str_s(authResponseLength);
        if ((this.clientFlag & Capabilities.CLIENT_CONNECT_WITH_DB) != 0) {
            this.database = decoder.str();
        } else {
            this.database = null;
        }
        if ((this.clientFlag & Capabilities.CLIENT_PLUGIN_AUTH) != 0) {
            this.authPluginName = decoder.str();
        } else {
            this.authPluginName = null;
        }
        if ((this.clientFlag & Capabilities.CLIENT_CONNECT_ATTRS) != 0) {
            // special case(no any data)
            final int kvLen = 0 == decoder.remaining() ? 0 : (int) decoder.lei_s();
            if (decoder.remaining() < kvLen) {
                throw new IllegalArgumentException("invalid handshake response");
            }
            final int limit = decoder.getPos() + kvLen;
            final List<Attribute> list = new ArrayList<>();
            while (decoder.getPos() < limit) {
                final byte[] key = decoder.le_str_s();
                final byte[] value = decoder.le_str_s();
                list.add(new Attribute(key, value));
            }
            if (decoder.getPos() > limit) {
                throw new IllegalArgumentException("invalid handshake response");
            }
            if (list.isEmpty()) {
                attributes = null;
            } else {
                attributes = list;
            }
        } else {
            this.attributes = null;
        }
        if ((this.clientFlag & Capabilities.CLIENT_ZSTD_COMPRESSION_ALGORITHM) != 0) {
            this.zstdCompressionLevel = (byte) decoder.u8_s();
        } else {
            this.zstdCompressionLevel = 0;
        }
    }

    @Override
    public void encode(Encoder encoder, int capabilities) throws IOException {
        // adjust clientFlag
        if (authResponse.length > 255) {
            clientFlag |= Capabilities.CLIENT_PLUGIN_AUTH_LENENC_CLIENT_DATA;
        }
        if (null == database) {
            clientFlag &= ~Capabilities.CLIENT_CONNECT_WITH_DB;
        }

        // then start build
        encoder.begin();

        encoder.u32(clientFlag);
        encoder.u32(maxPacketSize);
        encoder.u8(characterSet);
        encoder.zeros(23);
        if (null == username) {
            encoder.u8(0);
        } else {
            encoder.nt_str(username);
        }
        if (null == authResponse) {
            encoder.u8(0);
        } else {
            if (0 == (clientFlag & Capabilities.CLIENT_PLUGIN_AUTH_LENENC_CLIENT_DATA)) {
                encoder.u8(authResponse.length);
            } else {
                encoder.lei(authResponse.length);
            }
            encoder.str(authResponse);
        }
        if ((clientFlag & Capabilities.CLIENT_CONNECT_WITH_DB) != 0) {
            assert database != null;
            encoder.nt_str(database);
        }
        if ((clientFlag & Capabilities.CLIENT_PLUGIN_AUTH) != 0) {
            if (null == authPluginName) {
                encoder.u8(0);
            } else {
                encoder.nt_str(authPluginName);
            }
        }
        if ((clientFlag & Capabilities.CLIENT_CONNECT_ATTRS) != 0) {
            if (null != attributes) {
                // calc all length
                int len = 0;
                for (Attribute attr : attributes) {
                    len += Encoder.lei_len(attr.key.length) + attr.key.length
                        + Encoder.lei_len(attr.value.length) + attr.value.length;
                }
                encoder.lei(len);
                for (Attribute attr : attributes) {
                    encoder.le_str(attr.key);
                    encoder.le_str(attr.value);
                }
            } else {
                encoder.lei(0);
            }
        }
        if ((clientFlag & Capabilities.CLIENT_ZSTD_COMPRESSION_ALGORITHM) != 0) {
            encoder.u8(zstdCompressionLevel);
        }

        encoder.end();
    }

    @Override
    public String toString() {
        return "HandshakeResponse41{" +
            "clientFlag=0x" + Integer.toHexString(clientFlag) +
            ", maxPacketSize=" + maxPacketSize +
            ", characterSet=" + characterSet +
            ", username=" + (null == username ? "<empty>" : new String(username)) +
            ", authResponse=" + (null == authResponse ? "<null>" :
            '\n' + BytesTools.beautifulHex(authResponse, 0, authResponse.length) + '\n') +
            ", database=" + (null == database ? "<empty>" : new String(database)) +
            ", authPluginName=" + (null == authPluginName ? "<empty>" : new String(authPluginName)) +
            ", attributes=[" + (null == attributes ? "<empty>" :
            attributes.stream().map(Attribute::toString).collect(Collectors.joining(","))) +
            "], zstdCompressionLevel=" + zstdCompressionLevel +
            '}';
    }
}
